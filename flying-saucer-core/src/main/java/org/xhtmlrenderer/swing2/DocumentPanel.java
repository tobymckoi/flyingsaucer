/*
 * Copyright (C) 2014 Tobias Downer.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */

package org.xhtmlrenderer.swing2;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.logging.Level;
import javax.swing.*;
import javax.swing.event.MouseInputListener;

import org.w3c.dom.css.CSSPrimitiveValue;
import org.xhtmlrenderer.css.constants.CSSName;
import org.xhtmlrenderer.css.constants.IdentValue;
import org.xhtmlrenderer.css.parser.FSRGBColor;
import org.xhtmlrenderer.css.parser.PropertyValue;
import org.xhtmlrenderer.css.style.CalculatedStyle;
import org.xhtmlrenderer.css.style.derived.ColorValue;
import org.xhtmlrenderer.css.style.derived.LengthValue;
import org.xhtmlrenderer.css.style.derived.StringValue;
import org.xhtmlrenderer.dom.Document;
import org.xhtmlrenderer.dom.Element;
import org.xhtmlrenderer.dom.Node;
import org.xhtmlrenderer.extend.FSCanvas;
import org.xhtmlrenderer.extend.NamespaceHandler;
import org.xhtmlrenderer.layout.BoxBuilder;
import org.xhtmlrenderer.layout.BoxLoadInfo;
import org.xhtmlrenderer.layout.Layer;
import org.xhtmlrenderer.layout.LayoutContext;
import org.xhtmlrenderer.layout.PaintingInfo;
import org.xhtmlrenderer.layout.SharedContext;
import org.xhtmlrenderer.render.BlockBox;
import org.xhtmlrenderer.render.Box;
import org.xhtmlrenderer.render.RenderingContext;
import org.xhtmlrenderer.render.ViewportBox;
import org.xhtmlrenderer.resource.ImageResource;
import org.xhtmlrenderer.swing.Java2DFontContext;
import org.xhtmlrenderer.swing.Java2DOutputDevice;
import org.xhtmlrenderer.swing.SwingElementPane;
import org.xhtmlrenderer.util.Configuration;
import org.xhtmlrenderer.util.Uu;
import org.xhtmlrenderer.util.XRLog;

/**
 * A Flying Saucer Panel is the base Swing JPanel object upon which the
 * FlyingSaucer renderer presents a document. This panel may contain
 * interactive elements such as; hyperlinks that can be selected or clicked on,
 * hover effects, blocks that are highlighted, and embedded Swing components
 * (from form fields or embedded directly). The content of this panel therefore
 * may change over time either from user events or from events that are
 * generated by the user agent (such as progressive image loading).
 * <p>
 * This object deals with document presentation and event handling only.
 * <p>
 * All calls on this object must happen from the Swing event dispatcher thread.
 * Failure to ensure this will cause unpredictable results.
 *
 * @author Tobias Downer
 */
public class DocumentPanel extends JPanel implements Scrollable, FSCanvas {

    /**
     * The DocumentState object being rendered.
     */
    private DocumentState documentState;

    /**
     * The element panel where Swing components are rendered to.
     */
    private final SwingElementPane elementPane = new SwingElementPane();

    /**
     * Constructor.
     */
    public DocumentPanel() {
        setBackground(Color.white);
        setLayout(new BorderLayout());
        add(elementPane, BorderLayout.CENTER);

        addEventListeners();

    }

    public void scrollToTop() {
        if (!SwingUtilities.isEventDispatchThread()) {
           throw new AssertionError("Not dispatcher thread");
        }
        scrollRectToVisible(new Rectangle(0, 0, 5, 5));
    }

    /**
     * Adds Swing Event listeners.
     */
    private void addEventListeners() {
        MouseInputListener eventHandler = new DPEventHandler();
        addMouseListener(eventHandler);
        addMouseMotionListener(eventHandler);
    }

    private class DPEventHandler implements MouseInputListener {

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mousePressed(MouseEvent e) {
            Box mouseOverBox = find(e.getX(), e.getY());
            handleMousePress(mouseOverBox);
        }

        @Override
        public void mouseReleased(MouseEvent e) {
            Box mouseOverBox = find(e.getX(), e.getY());
            handleMouseRelease(mouseOverBox);
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            Box mouseOverBox = find(e.getX(), e.getY());
            handleMouseCursor(mouseOverBox);
        }

        @Override
        public void mouseExited(MouseEvent e) {
            setCursor(null);
            releaseActiveLink();
        }

        @Override
        public void mouseDragged(MouseEvent e) {
        }

        @Override
        public void mouseMoved(MouseEvent e) {
            Box mouseOverBox = find(e.getX(), e.getY());
            handleMouseCursor(mouseOverBox);
        }

    }

    // ---- State ----

    private Element hrefPressedElement = null;

    // looks to see if the given element has a link URI associated with it; if
    // so, returns the URI as a string, if not, returns null
    private Element findLink(Element e) {
        String uri = null;
        LoadedDocument loadedDoc = documentState.getLoadedDocument();
        if (loadedDoc != null) {
            SharedContext sharedContext = loadedDoc.getSharedContext();
            if (sharedContext != null) {
                NamespaceHandler namespaceHandler = sharedContext.getNamespaceHandler();
                for (Node node = e; node instanceof Element; node = node.getParentNode()) {
                    uri = namespaceHandler.getLinkUri((Element) node);
                    if (uri != null) {
                        return (Element) node;
                    }
                }
            }
        }
        return null;
    }

    private Element findHrefFromBox(Box box) {
        Element ele = box.getElement();
        if (ele != null) {
            return findLink(ele);
        }
        return null;
    }

    private void makeActiveLink(Element element) {
        hrefPressedElement = element;
    }

    private void releaseActiveLink() {
        hrefPressedElement = null;
    }

    private void handleUriClick(Element e, String uri) {
        // Notify the document state of the event (this will generate an event)
        documentState.uriHrefClick(e, uri);
    }

    private void handleHrefClick(Element e) {
        String uri = null;
        LoadedDocument loadedDoc = documentState.getLoadedDocument();
        if (loadedDoc != null) {
            SharedContext sharedContext = loadedDoc.getSharedContext();
            if (sharedContext != null) {
                NamespaceHandler namespaceHandler = sharedContext.getNamespaceHandler();
                uri = namespaceHandler.getLinkUri(e);
            }
        }
        handleUriClick(e, uri);
    }

    private void handleMousePress(Box box) {
        if (box != null) {
            Element href = findHrefFromBox(box);
            if (href != null) {
                makeActiveLink(href);
            }
        }
    }

    private void handleMouseRelease(Box box) {
        if (box != null) {
            Element href = findHrefFromBox(box);
            if (href != null) {
                if (href == hrefPressedElement) {
                    // Clicked on link,
                    handleHrefClick(href);
                }
                releaseActiveLink();
            }
        }
    }

    private void handleMouseCursor(Box box) {
        if (box != null) {
            Cursor c = box.getStyle().getCursor();
            if (!c.equals(getCursor())) {
                setCursor(c);
            }
        }
    }

    private final DocumentListener eventHandler = new DocumentListener() {
        @Override
        public void notify(final DocumentEvent evt) {
            // Dispatch to the AWT thread,
            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    // If it's a document loaded event,
                    if (evt instanceof LoadedDocumentEvent) {
                        setRootBox(null, null);
                        // Clear the elementPane of any replaced swing components,
                        elementPane.removeAll();
                        setNeedRelayout(true);
                    }
                    if (evt instanceof LoadedImageProgressEvent) {
                        LoadedImageProgressEvent levt =
                                                (LoadedImageProgressEvent) evt;
                        ImageResource ir = levt.getImageResource();
                        String uri = ir.getImageUri();
                        LayoutContext layoutCtx = layoutContext;
                        if (layoutCtx != null) {
                            java.util.List<BoxLoadInfo> boxes =
                                    layoutCtx.getBoxesRegisteredWithResource(uri);
                            repaintBoxes(boxes);
                        }
                        return;
                    }
                    repaint();
                }
            });
        }
    };

    /**
     * Repaint the list of boxes given.
     * 
     * @param boxes 
     */
    private void repaintBoxes(java.util.List<BoxLoadInfo> boxes) {
        // If any of the boxes need a relayout on load then request relayout,
        for (BoxLoadInfo boxLoadInfo : boxes) {
            if (boxLoadInfo.getStatusOperation() == BoxLoadInfo.STATUS_RELAYOUT) {
                repaint();
                return;
            }
        }
        // Repaint individual boxes,
        for (BoxLoadInfo boxLoadInfo : boxes) {
            PaintingInfo paintInfo = boxLoadInfo.getBox().getPaintingInfo();
            if (paintInfo != null) {
                Rectangle rect = paintInfo.getAggregateBounds();
                repaint(rect);
            }
            else {
                // Repaint the whole window,
                repaint();
            }
        }
    }

    /**
     * Sets the DocumentState object that maintains the state of a single
     * Document being rendered on this panel.
     * 
     * @param state
     */
    public void setDocumentState(DocumentState state) {
        if (!SwingUtilities.isEventDispatchThread()) {
            throw new AssertionError("Not event dispatcher thread.");
        }
        // Remove listener from the old document state,
        if (documentState != null) {
            documentState.removeListener(eventHandler);
        }

        this.documentState = state;
        // Add listener for the new state,
        state.addListener(eventHandler);

        // Repaint,
        repaint();

    }

    // -----

    private LayoutContext layoutContext;
    private Box rootBox;

    private boolean needRelayout;
    private boolean defaultFontFromComponent = false;

    private int default_scroll_mode = -1;
    protected JScrollPane enclosingScrollPane;
    private boolean viewportMatchWidth = true;



    public Box getRootBox() {
        return rootBox;
    }

    public void setRootBox(LayoutContext layoutContext, Box rootBox) {
        this.layoutContext = layoutContext;
        this.rootBox = rootBox;
    }

    public Layer getRootLayer() {
        return getRootBox() == null ? null : getRootBox().getLayer();
    }

    public Box find(int x, int y) {
        Layer l = getRootLayer();
        if (l != null) {
            return l.find(layoutContext, x, y, false);
        }
        return null;
    }

    private void paintDefaultBackground(Graphics g) {
        if (super.isOpaque()) {
            g.setColor(getBackground());
            g.fillRect(0, 0, getWidth(), getHeight());
        }
    }

    protected boolean isNeedRelayout() {
        return needRelayout;
    }

    protected void setNeedRelayout(boolean needRelayout) {
        this.needRelayout = needRelayout;
    }

    public boolean isDefaultFontFromComponent() {
        return defaultFontFromComponent;
    }

    public void setDefaultFontFromComponent(boolean defaultFontFromComponent) {
        this.defaultFontFromComponent = defaultFontFromComponent;
    }

    public void resetScrollPosition() {
        if (this.enclosingScrollPane != null) {
            this.enclosingScrollPane.getVerticalScrollBar().setValue(0);
        }
    }

    /**
     * The method is invoked by {@link #addNotify} and {@link #removeNotify} to
     * ensure that any enclosing {@link JScrollPane} works correctly with this
     * panel. This method can be safely invoked with a <tt>null</tt> scrollPane.
     *
     * @param scrollPane the enclosing {@link JScrollPane} or <tt>null</tt> if
     *                   the panel is no longer enclosed in a {@link JScrollPane}.
     */
    protected void setEnclosingScrollPane(JScrollPane scrollPane) {

        enclosingScrollPane = scrollPane;

        if (enclosingScrollPane != null) {
//            Uu.p("added root panel as a component listener to the scroll pane");
            default_scroll_mode = enclosingScrollPane.getViewport().getScrollMode();
        }
    }


    public RenderingContext newRenderingContext(
                                    Graphics2D g, LoadedDocument loadedDoc) {
        XRLog.layout(Level.FINEST, "new context begin");

        loadedDoc.getSharedContext().setCanvas(this);

        XRLog.layout(Level.FINEST, "new context end");

        // Set up the Java2D output device,
        Java2DOutputDevice outputDevice = new Java2DOutputDevice(g);
        outputDevice.setAntiAliasedShapesByDefault(
                        loadedDoc.getSharedContext().isAntiAliasingShapes());

        RenderingContext result = loadedDoc.getSharedContext().newRenderingContextInstance();
        result.setFontContext(new Java2DFontContext(g));
        result.setOutputDevice(outputDevice);

        loadedDoc.getSharedContext().getTextRenderer().setup(result.getFontContext());

        final Box rb = getRootBox();
        if (rb != null) {
            result.setRootLayer(rb.getLayer());
        }

        return result;
    }

    protected LayoutContext newLayoutContext(
                                    Graphics2D g, LoadedDocument loadedDoc) {

        XRLog.layout(Level.FINEST, "new context begin");

        loadedDoc.getSharedContext().setCanvas(this);

        XRLog.layout(Level.FINEST, "new context end");

        LayoutContext result = loadedDoc.getSharedContext().newLayoutContextInstance();

        Graphics2D layoutGraphics =
            g.getDeviceConfiguration().createCompatibleImage(1, 1).createGraphics();
        result.setFontContext(new Java2DFontContext(layoutGraphics));

        loadedDoc.getSharedContext().getTextRenderer().setup(result.getFontContext());

        return result;
    }

    private void initFontFromComponent(BlockBox root) {
        if (isDefaultFontFromComponent()) {
            CalculatedStyle style = root.getStyle();
            PropertyValue fontFamilyProp = new PropertyValue(CSSPrimitiveValue.CSS_STRING, getFont().getFamily(),
                    getFont().getFamily());
            fontFamilyProp.setStringArrayValue(new String[] { fontFamilyProp.getStringValue() });
            style.setDefaultValue(CSSName.FONT_FAMILY, new StringValue(CSSName.FONT_FAMILY, fontFamilyProp));
            style.setDefaultValue(CSSName.FONT_SIZE, new LengthValue(style, CSSName.FONT_SIZE,
                    new PropertyValue(CSSPrimitiveValue.CSS_PX, getFont().getSize(), Integer
                            .toString(getFont().getSize()))));
            Color c = getForeground();
            style.setDefaultValue(CSSName.COLOR, new ColorValue(CSSName.COLOR,
                    new PropertyValue(new FSRGBColor(c.getRed(), c.getGreen(), c.getBlue()))));

            if (getFont().isBold()) {
                style.setDefaultValue(CSSName.FONT_WEIGHT, IdentValue.BOLD);
            }

            if (getFont().isItalic()) {
                style.setDefaultValue(CSSName.FONT_STYLE, IdentValue.ITALIC);
            }
        }
    }

    public Rectangle getScreenExtents() {
        Rectangle extents;
        if (enclosingScrollPane != null) {
            Rectangle bnds = enclosingScrollPane.getViewportBorderBounds();
            extents = new Rectangle(0, 0, bnds.width, bnds.height);
            //Uu.p("bnds = " + bnds);
        }
        else {
            extents = new Rectangle(getWidth(), getHeight());
            Insets insets = getInsets();
            extents.width -= insets.left + insets.right;
            extents.height -= insets.top + insets.bottom;
        }
        return extents;
    }

    private Rectangle getInitialExtents(LayoutContext c) {
        Rectangle extents = getScreenExtents();
        // HACK avoid bogus warning
        if (extents.width == 0 && extents.height == 0) {
            extents = new Rectangle(0, 0, 1, 1);
        }
        return extents;
    }

    protected boolean isExtentsHaveChanged() {
        if (rootBox == null) {
            return true;
        }
        else {
            Rectangle oldExtents = ((ViewportBox) rootBox.getContainingBlock()).getExtents();
            return ! oldExtents.equals(getScreenExtents());
        }
    }

    public void doDocumentLayout(Graphics g, LoadedDocument loadedDoc) {
        try {

            if (g == null) {
                return;
            }

            Document doc = loadedDoc.getDom();

            if (doc == null) {
                return;
            }

            LayoutContext c = newLayoutContext((Graphics2D) g, loadedDoc);

            long start = System.currentTimeMillis();

            BlockBox root = (BlockBox)getRootBox();
            if (root != null && isNeedRelayout()) {
                root.reset(c);
            }
            else {
                root = BoxBuilder.createRootBox(c, doc);
                setRootBox(c, root);
            }

            initFontFromComponent(root);

            Rectangle initialExtents = getInitialExtents(c);
            root.setContainingBlock(new ViewportBox(initialExtents));

            root.layout(c);

            long end = System.currentTimeMillis();

            XRLog.layout(Level.INFO, "Layout took " + (end - start) + "ms");

            /*
            System.out.println(root.dump(c, "", BlockBox.DUMP_LAYOUT));
            */

            // if there is a fixed child then we need to set opaque to false
            // so that the entire viewport will be repainted. this is slower
            // but that's the hit you get from using fixed layout
            if (root.getLayer().containsFixedContent()) {
                super.setOpaque(false);
            }
            else {
                super.setOpaque(true);
            }

            XRLog.layout(Level.FINEST, "after layout: " + root);

            Dimension intrinsic_size = root.getLayer().getPaintingDimension(c);

            // If the initial size we fed into the layout matches the width
            // of the layout generated then we can set the scrollable property
            // that matches width of the view pane to the width of this panel.
            // Otherwise, if the intrinsic width is different then we can't
            // couple the width of the view pane to the width of this panel
            // (we hit the minimum size threshold).
            viewportMatchWidth = (initialExtents.width == intrinsic_size.width);

            setPreferredSize(intrinsic_size);
            revalidate();

            if (enclosingScrollPane != null) {
                // turn on simple scrolling mode if there's any fixed elements
                if (root.getLayer().containsFixedContent()) {
                    // Uu.p("is fixed");
                    enclosingScrollPane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);
                } else {
                    // Uu.p("is not fixed");
                    enclosingScrollPane.getViewport().setScrollMode(default_scroll_mode);
                }
            }

        }
        catch (ThreadDeath t) {
            throw t;
        }
        catch (Throwable t) {
            if (t instanceof Error) {
                throw (Error)t;
            }
            if (t instanceof RuntimeException) {
                throw (RuntimeException)t;
            }

            // "Shouldn't" happen
            XRLog.exception(t.getMessage(), t);
        }
    }

    protected void doRender(RenderingContext c, Layer root) {
        try {
            // paint the normal swing background first
            // but only if we aren't printing.
            Graphics g = ((Java2DOutputDevice)c.getOutputDevice()).getGraphics();

            paintDefaultBackground(g);

            if (enclosingScrollPane == null) {
                Insets insets = getInsets();
                g.translate(insets.left, insets.top);
            }

            long start = System.currentTimeMillis();

            root.paint(c);

            long after = System.currentTimeMillis();
            if (Configuration.isTrue("xr.incremental.repaint.print-timing", false)) {
                Uu.p("repaint took ms: " + (after - start));
            }
        }
        catch (ThreadDeath t) {
            throw t;
        }
        catch (Throwable t) {
            if (t instanceof Error) {
                throw (Error)t;
            }
            if (t instanceof RuntimeException) {
                throw (RuntimeException)t;
            }

            // "Shouldn't" happen
            XRLog.exception(t.getMessage(), t);
        }
    }

    /**
     * The Swing rendering method.
     * 
     * @param g 
     */
    @Override
    public void paintComponent(Graphics g) {

        LoadedDocument loadedDoc = documentState.getLoadedDocument();
        if (loadedDoc == null) {
            paintDefaultBackground(g);
            return;
        }

        Document doc = loadedDoc.getDom();

        if (doc == null) {
            paintDefaultBackground(g);
            return;
        }

        // if this is the first time painting this document, then calc layout
        Layer root = getRootLayer();
        if (root == null || isNeedRelayout()) {
            doDocumentLayout(g.create(), loadedDoc);
            root = getRootLayer();
        }

        setNeedRelayout(false);

        if (root == null) {
            //Uu.p("dispatching an initial resize event");
            //queue.dispatchLayoutEvent(new ReflowEvent(ReflowEvent.CANVAS_RESIZED, this.getSize()));
            XRLog.render(Level.FINE, "skipping the actual painting");
        }
        else {
            RenderingContext c =
                    newRenderingContext((Graphics2D) g.create(), loadedDoc);
            long start = System.currentTimeMillis();
            doRender(c, root);
            long end = System.currentTimeMillis();
            XRLog.render(Level.FINE, "RENDERING TOOK " + (end - start) + " ms");
        }
    }

    @Override
    public void doLayout() {
        if (isExtentsHaveChanged()) {
            setNeedRelayout(true);
        }
        super.doLayout();
    }

    @Override
    public void validate() {
        super.validate();

        if (isExtentsHaveChanged()) {
            setNeedRelayout(true);
        }
    }

    /**
     * Overrides the default implementation to test for and configure any {@link
     * JScrollPane} parent.
     */
    @Override
    public void addNotify() {
        super.addNotify();
        XRLog.general(Level.FINE, "add notify called");
        Container p = getParent();
        if (p instanceof JViewport) {
            Container vp = p.getParent();
            if (vp instanceof JScrollPane) {
                setEnclosingScrollPane((JScrollPane) vp);
            }
        }
    }

    /**
     * Overrides the default implementation unconfigure any {@link JScrollPane}
     * parent.
     */
    @Override
    public void removeNotify() {
        super.removeNotify();
        setEnclosingScrollPane(null);
    }

    // ----- FSCanvas interface -----

    /**
     * Gets the fixedRectangle attribute of the BasicPanel object
     *
     * @return The fixedRectangle value
     */
    @Override
    public Rectangle getFixedRectangle() {
        if (enclosingScrollPane != null) {
            return enclosingScrollPane.getViewportBorderBounds();
        }
        else {
            Dimension dim = getSize();
            return new Rectangle(0, 0, dim.width, dim.height);
        }
    }

    @Override
    public void paintSwingReplacedComponent(
                Graphics g, Component c, Rectangle bounds, boolean validate) {
        elementPane.paintComponent(g, c, bounds, validate);
    }

    // ----- Scrollable interface -----

    @Override
    public Dimension getPreferredScrollableViewportSize() {
      return getPreferredSize();
    }

    @Override
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
      int dif = 1;
      if (orientation == SwingConstants.VERTICAL) {
        dif = visibleRect.height;
      }
      else if (orientation == SwingConstants.HORIZONTAL) {
        dif = visibleRect.width;
      }
      return Math.min(35, dif);
    }

    @Override
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
      int dif = 1;
      if (orientation == SwingConstants.VERTICAL) {
        dif = Math.max(visibleRect.height - 10, dif);
      }
      else if (orientation == SwingConstants.HORIZONTAL) {
        dif = Math.max(visibleRect.width, dif);
      }
      return dif;
    }

    @Override
    public boolean getScrollableTracksViewportWidth() {
        // If the last layout successfully filled the desired width then
        // viewport should match the component size.
        return viewportMatchWidth;
    }

    @Override
    public boolean getScrollableTracksViewportHeight() {
        // If the last layout height of this component is <= the viewport
        // height then we make the viewport height match the component size.
        int viewportHeight = enclosingScrollPane.getViewport().getHeight();
        return getPreferredSize().height <= viewportHeight;
    }

}
